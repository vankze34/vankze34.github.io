<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-07-08T11:54:44+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Vans DS Gym</title><subtitle>데이터 사이언스 훈련장</subtitle><entry><title type="html">Programmers Solution - 다리를 지나는 트럭</title><link href="http://localhost:4000/algorithm3" rel="alternate" type="text/html" title="Programmers Solution - 다리를 지나는 트럭" /><published>2021-06-03T10:16:00+09:00</published><updated>2021-06-03T10:16:00+09:00</updated><id>http://localhost:4000/algorithm3</id><content type="html" xml:base="http://localhost:4000/algorithm3">&lt;p&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42583&quot;&gt;Programmers 문제 링크 바로가기&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[##_Image&lt;/td&gt;
      &lt;td&gt;kage@cSNPRZ/btq6mHaCezx/3lFaOepZuFqYF1usHgLKGK/img.png&lt;/td&gt;
      &lt;td&gt;alignCenter&lt;/td&gt;
      &lt;td&gt;width=”100%” data-origin-width=”1255” data-origin-height=”962” data-ke-mobilestyle=”widthOrigin”&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;_##]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;접근방식&quot;&gt;접근방식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;트럭은 동시에 탑승 할 수 없다 (직렬)&lt;/li&gt;
  &lt;li&gt;다리의 길이의 단위는 1초이므로 모든 트럭은 다리의 길이 만큼의 초가 경과한 경우 다리를 지나갈 수 있다&lt;/li&gt;
  &lt;li&gt;[한번에 올라갈 수 있는 트럭의 무게의 합 &amp;lt;= 다리가 견딜 수 있는 하중] 이어야 한다&lt;/li&gt;
  &lt;li&gt;더이상 다리에 트럭이 없어진 시간이 return된다 (다리 위의 트럭을 나타내는 배열이 비어있어야 한다)&lt;/li&gt;
  &lt;li&gt;가장 처음 들어간 트럭이 가장 먼저 나오므로 Queue의 개념으로 접근한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예) 다리의 길이(초)가 &lt;strong&gt;2&lt;/strong&gt;, 다리가 견딜 수 있는 하중: &lt;strong&gt;10&lt;/strong&gt;, 트럭의 무게: &lt;strong&gt;[7, 4, 5, 6]&lt;/strong&gt; 의 경우&lt;br /&gt;
※ [0]은 트럭이 타지 않은 빈 공간으로 한다 / 트럭은 오른쪽에서 왼쪽으로 이동&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;경과시간&lt;/th&gt;
      &lt;th&gt;다리를 건넌 트럭&lt;/th&gt;
      &lt;th&gt;다리를 건너는 트럭&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;대기 트럭&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;초기&lt;/td&gt;
      &lt;td&gt;[]&lt;/td&gt;
      &lt;td&gt;[0, 0]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[7, 4, 5, 6]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1&lt;/td&gt;
      &lt;td&gt;[]&lt;/td&gt;
      &lt;td&gt;[0, 7]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[4, 5, 6]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2&lt;/td&gt;
      &lt;td&gt;[]&lt;/td&gt;
      &lt;td&gt;[7, 0]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[4, 5, 6]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3&lt;/td&gt;
      &lt;td&gt;[7]&lt;/td&gt;
      &lt;td&gt;[0, 4]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[5, 6]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4&lt;/td&gt;
      &lt;td&gt;[7]&lt;/td&gt;
      &lt;td&gt;[4, 5]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[6]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;5&lt;/td&gt;
      &lt;td&gt;[7, 4]&lt;/td&gt;
      &lt;td&gt;[5, 0]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[6]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;6&lt;/td&gt;
      &lt;td&gt;[7, 4, 5]&lt;/td&gt;
      &lt;td&gt;[0, 6]&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;[]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;알고리즘&quot;&gt;알고리즘&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def solution(bridge_length, weight, truck_weights):
    answer = 0
    q = [0] * bridge_length                            # 다리의 길이만큼 리스트를 생성
    while q:                                        # q가 비어있지 않은 동안 반복
        answer += 1                                    # 1초씩 증가
        q.pop(0)                                    # q의 0번 index를 제거 (다리를 건넘)
        if truck_weights:                            # 대기중인 트럭이 있다면
            if sum(q) + truck_weights[0] &amp;lt;= weight: # [다리위의 트럭의 무게 + 첫번째 대기중인 트럭의 무게 &amp;lt;= 다리의 하중] 인 경우
                q.append(truck_weights.pop(0))        # 첫번째 대기중인 트럭을 대기열에서 빼서 q에 추가
            else:                                    # [다리위의 트럭의 무게 + 첫번째 대기중인 트럭의 무게 &amp;lt;= 다리의 하중] 이 아닌 경우
                q.append(0)                            # q에 0을 추가 (트럭이 타지 않음)

    return answer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Jaekwang Van</name></author><category term="algorithm" /><summary type="html">Programmers 문제 링크 바로가기</summary></entry><entry><title type="html">Programmers Solution - 기능개발</title><link href="http://localhost:4000/algorithm2" rel="alternate" type="text/html" title="Programmers Solution - 기능개발" /><published>2021-06-02T04:41:00+09:00</published><updated>2021-06-02T04:41:00+09:00</updated><id>http://localhost:4000/algorithm2</id><content type="html" xml:base="http://localhost:4000/algorithm2">&lt;p&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42586&quot;&gt;Programmers 문제 링크 바로가기&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[##_Image&lt;/td&gt;
      &lt;td&gt;kage@cLfinK/btq6kGozMrQ/XFAcoFtmh9XnQ47OFoIaO0/img.png&lt;/td&gt;
      &lt;td&gt;alignCenter&lt;/td&gt;
      &lt;td&gt;width=”100%” data-origin-width=”707” data-origin-height=”704” data-ke-mobilestyle=”widthOrigin”&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;_##][##_Image&lt;/td&gt;
      &lt;td&gt;kage@bKAhSq/btq6fSw0lcV/6iD4PKqi8EKqozy5k12C1K/img.png&lt;/td&gt;
      &lt;td&gt;alignCenter&lt;/td&gt;
      &lt;td&gt;width=”100%” data-origin-width=”700” data-origin-height=”451” data-ke-mobilestyle=”widthOrigin”&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;_##]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;접근방식&quot;&gt;접근방식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;각 인덱스별 작업 진도는 작업 속도(speeds)에 의해 100이 된 경우 작업이 끝난다&lt;/li&gt;
  &lt;li&gt;작업 속도(speeds)값은 하루에 처리할 수 있는 작업량이다&lt;/li&gt;
  &lt;li&gt;작업 진도(progresses)의 각 인덱스별 값은 순서를 갖고있어 더 늦은 인덱스의 작업이 끝나더라도 더 빠른 인덱스의 작업이 아직 안끝난 경우는 기다린 후 한번에 배포한다&lt;/li&gt;
  &lt;li&gt;한번에 배포되는 작업의 개수를 answer에 추가하여 return한다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예) progresses가 [93, 30, 55]이고, speeds가 [1, 30, 5]인 경우, 각 작업당 몇일 뒤에 끝날지(100이 되기까지의 일수) 계산 해보면 [7, 3, 9] (단위: 일)이 된다.&lt;br /&gt;
작업1(인덱스0)은 7일 뒤에 끝난다 -&amp;gt; 7일 뒤에 배포 가능 -&amp;gt; 바로 배포 가능&lt;br /&gt;
작업2(인덱스1)는 3일 뒤에 끝난다 -&amp;gt; 3일 뒤에 배포 가능 -&amp;gt; 하지만 3일 뒤에도 작업1이 끝나지 않았으므로 작업1과 같이 배포해야 함&lt;br /&gt;
작업3(인덱스2)는 9일 뒤에 끝난다 -&amp;gt; 9일 뒤에 배포 가능 -&amp;gt; 바로 배포 가능&lt;br /&gt;
그러므로 작업1과, 작업2를 한번에 배포: 2&lt;br /&gt;
작업3을 배포: 1&lt;br /&gt;
answer = [2, 2]&lt;br /&gt;
가 된다&lt;/p&gt;

&lt;h3 id=&quot;알고리즘&quot;&gt;알고리즘&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import math                         # 올림(ceil)을 사용하기 위해 import

def solution(progresses, speeds):
    n = len(progresses)             # progresses의 길이를 n에 저장 
    answer = []                     # answer는 빈 리스트로 둔다 
    left = [0] * n + [101]          # 작업 종료까지 남은 일수(left)를 초기화, 작업은 100을 넘지 못하므로 101을 추가로 넣어줌

    for i in range(n):              # progresses의 길이만큼 반복
        left[i] = math.ceil((100 - progresses[i]) / speeds[i])
                                    # 작업 종료까지 남은 일수를 계산 [(100-작업완료) / 작업속도] 를 올림 한 값
                                    # 올림 한 이유: 작업이 완벽히 100이 되지 않았으면 완료가 아니므로 100을 초과한 경우만 완료로 함
    ans= 0                          # 한번에 배포할 작업의 개수를 저장하기 위한 ans를 초기화 
    for i in range(n):              # progresses의 길이만큼 반복
        if left[i] &amp;lt; left[i+1]:     # 작업종료까지 남은 일수(left)가 다음 left보다 적은 경우는 바로 배포 가능
            ans+=1                  # 한번에 배포할 작업의 개수를 1 증가시킴
            answer.append(ans)      # ans를 answer에 추가
            ans=0                   # 배포 완료하였으므로 ans를 초기화
                                    # left의 마지막 값 101과 만난 경우는 무조건 if절로 들어와 ans를 증가시킨 뒤 answer에 추가

        else:                       # 작업종료까지 남은 일수(left)가 다음 left보다 적은 경우는 다음 작업을 기다려야 함
            ans+=1                  # 한번에 배포할 작업의 개수를 1 증가시킴
            left[i+1] = left[i]     # 현 작업(i)을 그 다음 작업(i+2)과 비교하기 위해 i+1에 i값을 대입하여 다시 반복

    return answer                   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Jaekwang Van</name></author><category term="algorithm" /><summary type="html">Programmers 문제 링크 바로가기</summary></entry><entry><title type="html">Programmers Solution - 주식 가격</title><link href="http://localhost:4000/algorithm1" rel="alternate" type="text/html" title="Programmers Solution - 주식 가격" /><published>2021-06-01T05:55:00+09:00</published><updated>2021-06-01T05:55:00+09:00</updated><id>http://localhost:4000/algorithm1</id><content type="html" xml:base="http://localhost:4000/algorithm1">&lt;p&gt;&lt;a href=&quot;https://programmers.co.kr/learn/courses/30/lessons/42584&quot;&gt;Programmers 문제 링크 바로가기&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[##_Image&lt;/td&gt;
      &lt;td&gt;kage@3Rjeh/btq6gLQr39f/nOFWSjmvDaw1dGWui93kg0/img.png&lt;/td&gt;
      &lt;td&gt;alignLeft&lt;/td&gt;
      &lt;td&gt;width=”100%” data-origin-width=”700” data-origin-height=”667” data-ke-mobilestyle=”widthOrigin”&lt;/td&gt;
      &lt;td&gt;Programmers 주식 가격&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;_##]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;접근방식&quot;&gt;접근방식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;배열 형태의 price가 인덱스마다 1초&lt;/li&gt;
  &lt;li&gt;n초 뒤의 주식 가격이 떨어진 경우의 결과물로 n을 기록&lt;/li&gt;
  &lt;li&gt;마지막까지 가격이 떨어지지 않은 경우는 결과물로 마지막까지의 초가 기록&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예) price가 [1, 2, 3, 2, 3]인 경우&lt;br /&gt;
0초인 경우 가격이 1이고, &lt;em&gt;4_초 뒤 까지 가격이 떨어지지 않아서 _4&lt;/em&gt;&lt;br /&gt;
1초인 경우 가격이 2이고, &lt;em&gt;3_초 뒤 까지 가격이 떨어지지 않아서 _3&lt;/em&gt;&lt;br /&gt;
2초인 경우 가격이 3이고, &lt;em&gt;1_초 뒤에 2로 가격이 떨어져서 _1&lt;/em&gt;&lt;br /&gt;
3초인 경우 가격이 2이고, &lt;em&gt;1_초 뒤 까지 가격이 떨어지지 않아서 _1&lt;/em&gt;&lt;br /&gt;
4초인 경우 가격이 3이고, 뒤의 값이 없으므로 &lt;em&gt;0&lt;/em&gt;&lt;br /&gt;
가 되어야 한다.&lt;/p&gt;

&lt;h3 id=&quot;알고리즘-나의-풀이&quot;&gt;알고리즘 (나의 풀이)&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def solution(prices):
    n = len(prices)  # price 배열의 길이를 n에 저장
    answer = [0] * n # 결과물 answer도 같은 길이로 생성(초기화)
    for i in range(n): # n번 반복을 하면서 가격이 떨어지는 것을 확인
        answer[i] = n-i-1 #  i번째 배열에서 남은 길이(초) 동안 가격이 떨어지는 경우를 위해 남은 길이(초) 전부를 넣는다
        for j in range(i+1, n): # i 이후부터 남은 길이 전부를 반복
            if(prices[i] &amp;gt; prices[j]): # i번째가격이 j번째 가격보다 큰 경우(가격이 떨어진 경우)는 
                answer[i] = j-i # 가격이 떨어진 index에서 i를 빼서 i번째 결과물에 입력
                break; # 떨어졌기때문에 내부 for문을 종료
    return answer # 다 저장된 answer를 리턴
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;알고리즘-다른-풀이-for문&quot;&gt;알고리즘 (다른 풀이: for문)&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def solution(prices):
    answer = [0] * len(prices)
    for i in range(len(prices)):
        for j in range(i+1, len(prices)):
            if prices[i] &amp;lt;= prices[j]:
                answer[i] += 1
            else:
                answer[i] += 1
                break
    return answer
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;알고리즘-다른-풀이-stack&quot;&gt;알고리즘 (다른 풀이: stack)&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def solution(p):
    ans = [0] * len(p)
    stack = [0]
    for i in range(1, len(p)):
        if p[i] &amp;lt; p[stack[-1]]:
            for j in stack[::-1]:
                if p[i] &amp;lt; p[j]:
                    ans[j] = i-j
                    stack.remove(j)
                else:
                    break
        stack.append(i)
    for i in range(0, len(stack)-1):
        ans[stack[i]] = len(p) - stack[i] - 1
    return ans
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;알고리즘-다른-풀이-queue&quot;&gt;알고리즘 (다른 풀이: Queue)&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from collections import deque
def solution(prices):
    answer = []
    prices = deque(prices)
    while prices:
        c = prices.popleft()

        count = 0
        for i in prices:
            if c &amp;gt; i:
                count += 1
                break
            count += 1

        answer.append(count)

    return answer

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[##_Image&lt;/td&gt;
      &lt;td&gt;kage@pAwg5/btq6gBf7Ast/naCt4UD2aICyQKz1MebAl0/img.png&lt;/td&gt;
      &lt;td&gt;alignCenter&lt;/td&gt;
      &lt;td&gt;width=”100%” data-origin-width=”516” data-origin-height=”584” data-ke-mobilestyle=”widthOrigin”&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;_##]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Jaekwang Van</name></author><category term="algorithm" /><summary type="html">Programmers 문제 링크 바로가기</summary></entry><entry><title type="html">List를 Stack이나 Queue처럼 사용하기</title><link href="http://localhost:4000/python1" rel="alternate" type="text/html" title="List를 Stack이나 Queue처럼 사용하기" /><published>2021-05-18T18:43:00+09:00</published><updated>2021-05-18T18:43:00+09:00</updated><id>http://localhost:4000/python1</id><content type="html" xml:base="http://localhost:4000/python1">&lt;h3 id=&quot;stack&quot;&gt;Stack&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;stack_list = [100, 200]
stack_list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[100, 200]&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;stack_list.append(300)
stack_list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[100, 200, 300]&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;stack_list.pop()
stack_list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[100, 200]&lt;/p&gt;

&lt;h3 id=&quot;queue&quot;&gt;Queue&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;queue_list = [&apos;a&apos;, &apos;b&apos;]
queue_list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[‘a’, ‘b’]&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;queue_list.append(&apos;c&apos;)
queue_list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[‘a’, ‘b’, ‘c’]&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;queue_list.pop(0)
queue_list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;[‘b’, ‘c’]&lt;/p&gt;</content><author><name>Jaekwang Van</name></author><category term="python" /><summary type="html">Stack</summary></entry></feed>